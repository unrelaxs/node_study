/* 验证模块第一次加载后，被缓存 */
var say = require('./hello');
var say1 = require('./hello');

console.log(say())
console.log(say1())
console.log(say())
console.log(say())

/* 如果每次加载模块，每次初始化模块，则答案如下
* 第一次 1
* 第二次 1
* 第三次 2
* 第四次 3
*
* 如果每次加载模块，第一次模块被缓存下来，则答案如下
* 第一次 1
* 第二次 2 （由于第一次模块say缓存，所以调用add1时在第一次加载的say模块基础上+1）
* 第三次 3
* 第四次 4
*
* 缓存说法行得通，但通过由此想象，require加载的模块文件，他们作用域共同吗？
* 不共同，因为他们都是都exports, module.exports导出的，加载的模块都属于这两个模块的
* 为了验证说法可以这样
* console.log(add())
* //add方法在hello.js文件下，直接在本文件中执行，发现是undefined,,add方法，因此作用域是不一样的
*
* 针对缓存问题，浏览器的js和nodejs的缓存一样吗？
* 浏览器缓存是不一样的，浏览器是缓存文件，往往是第一次加载时候，下载该文件，如果不强制ctrl+f5，则一些资源文件都是直接下载来。提高访问速度
* 而nodejs是第一次加载时候，缓存到服务器内存当中。
* */
